# Stubs for docutils.utils.math.math2html (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, AnyStr, Callable, ClassVar, Dict, List, MutableSequence, Optional, Sequence, TextIO, Tuple, Type, TypeVar, Union

class Trace:
    debugmode: bool = ...
    quietmode: bool = ...
    showlinesmode: bool = ...
    prefix: ClassVar[Optional[str]] = ...
    def debug(cls: Any, message: str) -> None: ...
    def message(cls: Any, message: str) -> None: ...
    def error(cls: Any, message: str) -> None: ...
    def fatal(cls: Any, message: str) -> None: ...
    def show(cls: Any, message: str, channel: TextIO) -> None: ...
    debug: classmethod = ...  # type: ignore
    message: classmethod = ...  # type: ignore
    error: classmethod = ...  # type: ignore
    fatal: classmethod = ...  # type: ignore
    show: classmethod = ...  # type: ignore

class BibStylesConfig:
    abbrvnat: Dict[str, str] = ...
    alpha: Dict[str, str] = ...
    authordate2: Dict[str, str] = ...
    default: Dict[str, str] = ...
    defaulttags: Dict[str, str] = ...
    ieeetr: Dict[str, str] = ...
    plain: Dict[str, str] = ...
    vancouver: Dict[str, str] = ...

class BibTeXConfig:
    replaced: Dict[str, str] = ...

class ContainerConfig:
    endings: Dict[str, str] = ...
    extracttext: Dict[str, str] = ...
    startendings: Dict[str, str] = ...
    starts: Dict[str, str] = ...
    string: Dict[str, str] = ...
    table: Dict[str, List[str]] = ...

class EscapeConfig:
    chars: Dict[str, str] = ...
    commands: Dict[str, str] = ...
    entities: Dict[str, str] = ...
    html: Dict[str, str] = ...
    iso885915: Dict[str, str] = ...
    nonunicode: Dict[str, str] = ...

class FormulaConfig:
    alphacommands: Dict[str, str] = ...
    array: Dict[str, str] = ...
    bigbrackets: Dict[str, List[str]] = ...
    bigsymbols: Dict[str, List[str]] = ...
    bracketcommands: Dict[str, str] = ...
    combiningfunctions: Dict[str, str] = ...
    commands: Dict[str, str] = ...
    decoratedcommand: Dict[Any, Any] = ...
    decoratingfunctions: Dict[str, str] = ...
    endings: Dict[str, str] = ...
    environments: Dict[str, List[str]] = ...
    fontfunctions: Dict[str, str] = ...
    hybridfunctions: Dict[str, List[str]] = ...
    hybridsizes: Dict[str, str] = ...
    labelfunctions: Dict[str, str] = ...
    limitcommands: Dict[str, str] = ...
    misccommands: Dict[str, str] = ...
    modified: Dict[str, str] = ...
    onefunctions: Dict[str, str] = ...
    spacedcommands: Dict[str, str] = ...
    starts: Dict[str, str] = ...
    symbolfunctions: Dict[str, str] = ...
    textfunctions: Dict[str, str] = ...
    unmodified: Dict[str, List[str]] = ...
    urls: Dict[str, str] = ...

class GeneralConfig:
    version: Dict[str, str] = ...

class HeaderConfig:
    parameters: Dict[str, str] = ...
    styles: Dict[str, List[str]] = ...

class ImageConfig:
    converters: Dict[str, str] = ...
    cropboxformats: Dict[str, str] = ...
    formats: Dict[str, Union[str, List[str]]] = ...

class LayoutConfig:
    groupable: Dict[str, List[str]] = ...

class NewfangleConfig:
    constants: Dict[str, str] = ...

class NumberingConfig:
    layouts: Dict[str, List[str]] = ...
    sequence: Dict[str, List[str]] = ...

class StyleConfig:
    hspaces: Dict[str, str] = ...
    quotes: Dict[str, str] = ...
    referenceformats: Dict[str, str] = ...
    size: Dict[str, List[str]] = ...
    vspaces: Dict[str, str] = ...

class TOCConfig:
    extractplain: Dict[str, List[str]] = ...
    extracttitle: Dict[str, List[str]] = ...

class TagConfig:
    barred: Dict[str, str] = ...
    family: Dict[str, str] = ...
    flex: Dict[str, str] = ...
    group: Dict[str, List[str]] = ...
    layouts: Dict[str, str] = ...
    listitems: Dict[str, str] = ...
    notes: Dict[str, str] = ...
    script: Dict[str, str] = ...
    shaped: Dict[str, str] = ...

class TranslationConfig:
    constants: Dict[str, str] = ...
    languages: Dict[str, str] = ...

class CommandLineParser:
    options: Type[Options] = ...
    def __init__(self, options: Type[Options]) -> None: ...
    def parseoptions(self, args: Sequence[str]) -> Optional[str]: ...
    def readoption(self, args: Sequence[str]) -> Tuple[str, Union[str, bool, None]]: ...
    def readquoted(self, args: Sequence[str], initial: str): ...
    def readequalskey(self, arg: str, args: MutableSequence[str]) -> str: ...

class Options:
    instance: Any = ...
    location: Any = ...
    nocopy: bool = ...
    copyright: bool = ...
    debug: bool = ...
    quiet: bool = ...
    version: bool = ...
    hardversion: bool = ...
    versiondate: bool = ...
    html: bool = ...
    help: bool = ...
    showlines: bool = ...
    str: bool = ...
    iso885915: bool = ...
    css: List[Any] = ...
    favicon: __builtins__.str = ...
    title: Any = ...
    directory: Any = ...
    destdirectory: Any = ...
    toc: bool = ...
    toctarget: __builtins__.str = ...
    tocfor: Any = ...
    forceformat: Any = ...
    lyxformat: bool = ...
    target: Any = ...
    splitpart: Any = ...
    memory: bool = ...
    lowmem: bool = ...
    nobib: bool = ...
    converter: __builtins__.str = ...
    raw: bool = ...
    jsmath: Any = ...
    mathjax: Any = ...
    nofooter: bool = ...
    simplemath: bool = ...
    template: Any = ...
    noconvert: bool = ...
    notoclabels: bool = ...
    letterfoot: bool = ...
    numberfoot: bool = ...
    symbolfoot: bool = ...
    hoverfoot: bool = ...
    marginfoot: bool = ...
    endfoot: bool = ...
    supfoot: bool = ...
    alignfoot: bool = ...
    footnotes: Optional[__builtins__.str] = ...
    imageformat: Optional[__builtins__.str] = ...
    copyimages: bool = ...
    googlecharts: bool = ...
    embedcss: List[Any] = ...
    branches: Dict[Any, Any] = ...
    def parseoptions(self, args: MutableSequence[__builtins__.str]) -> None: ...
    def processoptions(self) -> None: ...
    def usage(self) -> None: ...
    def parsefootnotes(self) -> None: ...
    def showoptions(self) -> None: ...
    def showversion(self) -> None: ...
    def showhardversion(self) -> None: ...
    def showversiondate(self) -> None: ...
    def showlyxformat(self) -> None: ...

class BranchOptions:
    name: str = ...
    options: Dict[str, str] = ...
    def __init__(self, name: str) -> None: ...
    def set(self, key: str, value: str): ...
    def isselected(self) -> bool: ...
    def __unicode__(self) -> str: ...

_C = TypeVar('_C')

class Cloner:
    def clone(cls: Any, original: _C) -> _C: ...
    def create(cls: Any, type: Type[_C]) -> _C: ...
    clone: classmethod = ...  # type: ignore
    create: classmethod = ...  # type: ignore

class ContainerExtractor:
    allowed: List[str] = ...
    cloned: List[str] = ...
    extracted: List[str] = ...
    def __init__(self, config: Dict[str, List[str]]) -> None: ...
    def extract(self, container: Container) -> List[Container]: ...
    def process(self, container: Container, list: List[Container]) -> None: ...
    def safeclone(self, container: Container) -> Container: ...

class Parser:
    begin: int = ...
    parameters: Dict[str, Union[Dict[str, str], bool, str]] = ...
    def __init__(self) -> None: ...
    def parseheader(self, reader: LineReader) -> List[str]: ...
    def parseparameter(self, reader: LineReader) -> None: ...
    def parsexml(self, reader: LineReader) -> Tuple[str, Dict[str, str]]: ...
    def parseending(self, reader: LineReader, process: Callable[..., None]) -> None: ...
    def parsecontainer(self, reader: LineReader, contents: List[Container]) -> None: ...
    def __unicode__(self) -> str: ...

class LoneCommand(Parser):
    def parse(self, reader) -> List[Any]: ...

class TextParser(Parser):
    stack: List[str] = ...
    ending: str = ...
    endings: List[str] = ...
    def __init__(self, container: Container) -> None: ...
    def parse(self, reader) -> List[Container]: ...
    def isending(self, reader) -> bool: ...

class ExcludingParser(Parser):
    def parse(self, reader: LineReader) -> List[Container]: ...

class BoundedParser(ExcludingParser):
    def parse(self, reader: LineReader) -> List[Container]: ...

class BoundedDummy(Parser):
    def parse(self, reader: LineReader) -> List[Container]: ...

class StringParser(Parser):
    begin: int = ...
    def parseheader(self, reader: LineReader) -> List[Any]: ...
    def parse(self, reader: LineReader) -> List[Container]: ...

class InsetParser(BoundedParser):
    def parse(self, reader: LineReader) -> List[Container]: ...

class ContainerOutput:
    def gethtml(self, container: Container) -> Any: ...
    def isempty(self) -> bool: ...

class EmptyOutput(ContainerOutput):
    def gethtml(self, container: Container) -> List[Any]: ...
    def isempty(self) -> bool: ...

class FixedOutput(ContainerOutput):
    def gethtml(self, container: Container) -> List[AnyStr]: ...

class ContentsOutput(ContainerOutput):
    def gethtml(self, container: Container) -> List[AnyStr]: ...

class TaggedOutput(ContentsOutput):
    tag: Any = ...
    breaklines: bool = ...
    empty: bool = ...
    def settag(self, tag, breaklines: bool = ..., empty: bool = ...) -> TaggedOutput: ...
    def setbreaklines(self, breaklines: bool) -> TaggedOutput: ...
    def gethtml(self, container: Container) -> List[AnyStr]: ...
    def open(self, container: Container) -> str: ...
    def close(self, container: Container) -> str: ...
    def selfclosing(self, container: Container) -> str: ...
    def checktag(self) -> bool: ...

class FilteredOutput(ContentsOutput):
    filters: List[Tuple[str, str]] = ...
    def __init__(self) -> None: ...
    def addfilter(self, original: str, replacement: str) -> None: ...
    def gethtml(self, container: Container) -> List[AnyStr]: ...
    def filter(self, line: AnyStr) -> AnyStr: ...

class StringOutput(ContainerOutput):
    def gethtml(self, container: Container) -> List[AnyStr]: ...

class LineReader:
    file: TextIO = ...
    linenumber: int = ...
    lastline: Optional[int] = ...
    current: Optional[str] = ...
    mustread: bool = ...
    depleted: bool = ...
    def __init__(self, filename: Union[TextIO, str]) -> None: ...
    def setstart(self, firstline: int) -> None: ...
    def setend(self, lastline: Optional[int]) -> None: ...
    def currentline(self) -> Optional[str]: ...
    def nextline(self) -> None: ...
    def readline(self) -> None: ...
    def finished(self) -> bool: ...
    def close(self) -> None: ...

class LineWriter:
    file: bool = ...
    filename: Optional[str] = ...
    def __init__(self, filename: Union[TextIO, str]) -> None: ...
    def write(self, strings: Sequence[str]) -> None: ...
    def writestring(self, string: str) -> None: ...
    def writeline(self, line: str) -> None: ...
    def close(self) -> None: ...

class Globable:
    leavepending: bool = ...
    endinglist: EndingList = ...
    def __init__(self) -> None: ...
    def checkbytemark(self) -> None: ...
    def isout(self) -> bool: ...
    def current(self) -> str: ...
    def checkfor(self, string: str) -> bool: ...
    def finished(self) -> bool: ...
    def skipcurrent(self) -> str: ...
    def glob(self, currentcheck: Callable[[], bool]) -> str: ...
    def globalpha(self) -> str: ...
    def globnumber(self) -> str: ...
    def isidentifier(self) -> bool: ...
    def globidentifier(self) -> str: ...
    def isvalue(self) -> bool: ...
    def globvalue(self) -> str: ...
    def skipspace(self) -> str: ...
    def globincluding(self, magicchar: str) -> str: ...
    def globexcluding(self, excluded: str) -> str: ...
    def pushending(self, ending: str, optional: bool = ...) -> None: ...
    def popending(self, expected: Optional[str] = ...) -> Optional[str]: ...
    def nextending(self) -> Optional[str]: ...

class EndingList:
    endings: List[PositionEnding] = ...
    def __init__(self) -> None: ...
    def add(self, ending: str, optional: bool = ...) -> None: ...
    def pickpending(self, pos: Position) -> None: ...
    def checkin(self, pos: Position) -> bool: ...
    def pop(self, pos: Position) -> str: ...
    def findending(self, pos: Position) -> Optional[str]: ...
    def checkpending(self) -> None: ...
    def __unicode__(self) -> str: ...

class PositionEnding:
    ending: str = ...
    optional: bool = ...
    def __init__(self, ending: str, optional: bool) -> None: ...
    def checkin(self, pos: Position) -> bool: ...
    def __unicode__(self) -> str: ...

class Position(Globable):
    def __init__(self) -> None: ...
    def skip(self, string: str) -> None: ...
    def identifier(self) -> str: ...
    def extract(self, length: int) -> Optional[str]: ...
    def checkfor(self, string: str) -> bool: ...
    def checkforlower(self, string: str) -> bool: ...
    def skipcurrent(self) -> str: ...
    def __next__(self) -> str: ...
    def checkskip(self, string: str) -> bool: ...
    def error(self, message: str) -> None: ...

class TextPosition(Position):
    pos: int = ...
    text: str = ...
    def __init__(self, text: str) -> None: ...
    def skip(self, string: str) -> None: ...
    def identifier(self) -> str: ...
    def isout(self) -> bool: ...
    def current(self) -> str: ...
    def extract(self, length) -> Optional[str]: ...

class FilePosition(Position):
    reader: LineReader = ...
    pos: int = ...
    def __init__(self, filename: Union[TextIO, str]) -> None: ...
    def skip(self, string: str) -> None: ...
    def currentline(self) -> Optional[str]: ...
    def nextline(self) -> None: ...
    def linenumber(self) -> int: ...
    def identifier(self) -> str: ...
    def isout(self) -> bool: ...
    def current(self) -> str: ...
    def extract(self, length: int) -> str: ...

class Container:
    partkey: Any = ...
    parent: Any = ...
    begin: Any = ...
    contents: List[Any] = ...
    def __init__(self) -> None: ...
    def process(self) -> None: ...
    def gethtml(self) -> List[str]: ...
    def escapeall(self, lines: Sequence[str]) -> List[str]: ...
    def escape(self, line: str, replacements: Dict[str, str] = ...) -> str: ...
    def escapeentities(self, line: str) -> str: ...
    def searchall(self, type: Type) -> List[Container]: ...
    def searchremove(self, type: Type) -> List[Container]: ...
    def searchprocess(self, type: Type, process: Callable[[Container], List[Container]]) -> None: ...
    def locateprocess(self, locate: Callable[[Container], bool], process: Callable[[Container], List[Container]]) -> None: ...
    def recursivesearch(self, locate: Callable[[Container], bool], recursive: Callable[[Container], bool], process: Callable[[Container], None]) -> None: ...
    def extracttext(self) -> str: ...
    def group(self, index: int, group, isingroup: Callable[[Any], bool]) -> None: ...
    def remove(self, index: int) -> None: ...
    def tree(self, level: int = ...) -> None: ...
    def getparameter(self, name: str) -> str: ...
    def getparameterlist(self, name: str) -> List[str]: ...
    def hasemptyoutput(self) -> bool: ...
    def __unicode__(self) -> str: ...

class BlackBox(Container):
    parser: LoneCommand = ...
    output: EmptyOutput = ...
    contents: List[Any] = ...
    def __init__(self) -> None: ...

class LyXFormat(BlackBox):
    def process(self) -> None: ...

class StringContainer(Container):
    parsed: Any = ...
    parser: StringParser = ...
    output: StringOutput = ...
    string: str = ...
    def __init__(self) -> None: ...
    def process(self) -> None: ...
    def replacespecial(self, line: str) -> str: ...
    def changeline(self, line: str) -> str: ...
    def extracttext(self) -> str: ...
    def __unicode__(self) -> str: ...

class Constant(StringContainer):
    contents: List[Any] = ...
    string: str = ...
    output: StringOutput = ...
    def __init__(self, text: str) -> None: ...
    def __unicode__(self) -> str: ...

class TaggedText(Container):
    output: TaggedOutput = ...
    parser: TextParser = ...
    def __init__(self) -> None: ...
    contents: List[Constant] = ...
    def complete(self, contents: List[Constant], tag: str, breaklines: bool = ...): ...
    def constant(self, text: str, tag: str, breaklines: bool = ...): ...
    def __unicode__(self) -> str: ...

class DocumentParameters:
    pdftitle: Any = ...
    indentstandard: bool = ...
    tocdepth: int = ...
    startinglevel: int = ...
    maxdepth: int = ...
    language: Any = ...
    bibliography: Any = ...
    outputchanges: bool = ...
    displaymode: bool = ...

class FormulaParser(Parser):
    begin: int = ...
    def parseheader(self, reader): ...
    def parsetype(self, reader: LineReader) -> Optional[str]: ...
    def parse(self, reader: LineReader) -> str: ...
    def parseformula(self, reader: LineReader) -> str: ...
    def parsesingleliner(self, reader: LineReader, start: str, ending: str) -> str: ...
    def parsemultiliner(self, reader: LineReader, start: str, ending: str) -> str: ...

class MacroParser(FormulaParser):
    begin: int = ...
    def parseheader(self, reader: LineReader) -> List[str]: ...
    def parse(self, reader: LineReader) -> str: ...

class FormulaBit(Container):
    type: Any = ...
    size: int = ...
    original: str = ...
    contents: List[FormulaBit] = ...
    output: ContentsOutput = ...
    def __init__(self) -> None: ...
    factory: FormulaFactory = ...
    def setfactory(self, factory: FormulaFactory) -> FormulaBit: ...
    def add(self, bit: FormulaBit): ...
    def skiporiginal(self, string: str, pos: Position) -> None: ...
    def computesize(self) -> int: ...
    def clone(self): ...
    def __unicode__(self): ...

class TaggedBit(FormulaBit):
    output: Any = ...
    def constant(self, constant, tag): ...
    contents: Any = ...
    def complete(self, contents, tag, breaklines: bool = ...): ...
    def selfcomplete(self, tag): ...

class FormulaConstant(Constant):
    original: Any = ...
    size: int = ...
    type: Any = ...
    def __init__(self, string) -> None: ...
    def computesize(self): ...
    def clone(self): ...
    def __unicode__(self): ...

class RawText(FormulaBit):
    def detect(self, pos): ...
    type: str = ...
    def parsebit(self, pos): ...

class FormulaSymbol(FormulaBit):
    modified: Any = ...
    unmodified: Any = ...
    def detect(self, pos): ...
    def parsebit(self, pos): ...
    def addsymbol(self, symbol, pos): ...

class FormulaNumber(FormulaBit):
    def detect(self, pos): ...
    type: str = ...
    def parsebit(self, pos): ...

class Comment(FormulaBit):
    start: Any = ...
    def detect(self, pos): ...
    def parsebit(self, pos): ...

class WhiteSpace(FormulaBit):
    def detect(self, pos): ...
    def parsebit(self, pos): ...
    def __unicode__(self): ...

class Bracket(FormulaBit):
    start: Any = ...
    ending: Any = ...
    inner: Any = ...
    def __init__(self) -> None: ...
    def detect(self, pos): ...
    def parsebit(self, pos): ...
    def parsetext(self, pos): ...
    def parseliteral(self, pos): ...
    def parsecomplete(self, pos, innerparser): ...
    def innerformula(self, pos): ...
    def innertext(self, pos): ...
    literal: str = ...
    def innerliteral(self, pos): ...

class SquareBracket(Bracket):
    start: Any = ...
    ending: Any = ...
    def clone(self): ...

class MathsProcessor:
    def process(self, contents, index): ...
    def __unicode__(self): ...

class FormulaProcessor:
    processors: Any = ...
    def process(self, bit): ...
    def processcontents(self, bit): ...
    def processinsides(self, bit): ...
    def traversewhole(self, formula): ...
    def traverse(self, bit): ...
    def italicize(self, bit, contents): ...

class Formula(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    def process(self): ...
    contents: Any = ...
    def jsmath(self): ...
    def mathjax(self): ...
    def googlecharts(self): ...
    def classic(self): ...
    def parse(self, pos): ...
    header: Any = ...
    def parsedollarinline(self, pos): ...
    def parsedollarblock(self, pos): ...
    parsed: Any = ...
    def parsedollar(self, pos): ...
    def parseinlineto(self, pos, limit): ...
    def parseblockto(self, pos, limit): ...
    def parseupto(self, pos, limit): ...
    def __unicode__(self): ...

class WholeFormula(FormulaBit):
    def detect(self, pos): ...
    def parsebit(self, pos): ...

class FormulaFactory:
    types: Any = ...
    skippedtypes: Any = ...
    defining: bool = ...
    instances: Any = ...
    def __init__(self) -> None: ...
    def detecttype(self, type, pos): ...
    def instance(self, type): ...
    def create(self, type): ...
    def clearskipped(self, pos): ...
    def skipany(self, pos): ...
    def parseany(self, pos): ...
    def parsetype(self, type, pos): ...
    def parseformula(self, formula): ...

class Translator:
    instance: Any = ...
    def translate(cls, key): ...
    translate: Any = ...
    translation: Any = ...
    first: bool = ...
    def __init__(self) -> None: ...
    langcodes: Any = ...
    def findtranslation(self): ...
    def getmessage(self, key): ...
    def getuntranslated(self, key): ...

class NumberCounter:
    name: Any = ...
    value: Any = ...
    mode: Any = ...
    master: Any = ...
    letters: str = ...
    symbols: Any = ...
    romannumerals: Any = ...
    def __init__(self, name) -> None: ...
    def setmode(self, mode): ...
    def init(self, value): ...
    def gettext(self): ...
    def getletter(self): ...
    def getsymbol(self): ...
    def getsequence(self, sequence): ...
    def getroman(self): ...
    def getvalue(self): ...
    def getnext(self): ...
    def reset(self): ...
    def __unicode__(self): ...

class DependentCounter(NumberCounter):
    master: Any = ...
    last: Any = ...
    def setmaster(self, master): ...
    def getnext(self): ...
    def getvalue(self): ...

class NumberGenerator:
    chaptered: Any = ...
    generator: Any = ...
    romanlayouts: Any = ...
    orderedlayouts: Any = ...
    counters: Any = ...
    appendix: Any = ...
    def deasterisk(self, type): ...
    def isunique(self, type): ...
    def isroman(self, type): ...
    def isinordered(self, type): ...
    def isnumbered(self, type): ...
    def isunordered(self, type): ...
    def getlevel(self, type): ...
    def getparttype(self, type): ...
    def generate(self, type): ...
    def getcounter(self, type): ...
    def create(self, type): ...
    def getdependentcounter(self, type, master): ...
    def createdependent(self, type, master): ...
    def startappendix(self): ...

class ChapteredGenerator(NumberGenerator):
    def generate(self, type): ...

class ContainerSize:
    width: Any = ...
    height: Any = ...
    maxwidth: Any = ...
    maxheight: Any = ...
    scale: Any = ...
    def set(self, width: Any = ..., height: Any = ...): ...
    def setmax(self, maxwidth: Any = ..., maxheight: Any = ...): ...
    def readparameters(self, container): ...
    def setparameter(self, container, name): ...
    def setvalue(self, name, value): ...
    def checkvalidheight(self, container): ...
    def processparameter(self, value): ...
    def extractnumber(self, text): ...
    def checkimage(self, width, height): ...
    def scalevalue(self, value): ...
    def removepercentwidth(self): ...
    def addstyle(self, container): ...
    def styleparameter(self, name): ...

class QuoteContainer(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    type: Any = ...
    html: Any = ...
    def process(self): ...

class LyXLine(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    html: Any = ...
    def process(self): ...

class EmphaticText(TaggedText):
    def process(self): ...

class ShapedText(TaggedText):
    type: Any = ...
    def process(self): ...

class VersalitasText(TaggedText):
    def process(self): ...

class ColorText(TaggedText):
    color: Any = ...
    def process(self): ...

class SizeText(TaggedText):
    size: Any = ...
    def process(self): ...

class BoldText(TaggedText):
    def process(self): ...

class TextFamily(TaggedText):
    type: Any = ...
    def process(self): ...

class Hfill(TaggedText):
    def process(self): ...

class BarredText(TaggedText):
    type: Any = ...
    def process(self): ...

class LangLine(TaggedText):
    output: Any = ...
    def process(self): ...

class InsetLength(BlackBox):
    length: Any = ...
    def process(self): ...

class Space(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    type: Any = ...
    html: Any = ...
    def process(self): ...
    def getlength(self): ...

class VerticalSpace(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    type: Any = ...
    html: Any = ...
    def process(self): ...

class Align(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    def process(self): ...

class Newline(Container):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    html: Any = ...
    def process(self): ...

class NewPage(Newline):
    html: Any = ...
    def process(self): ...

class Separator(Container):
    output: Any = ...
    contents: Any = ...
    html: Any = ...
    def __init__(self, constant) -> None: ...

class StrikeOut(TaggedText):
    def process(self): ...

class StartAppendix(BlackBox):
    def process(self): ...

class Link(Container):
    anchor: Any = ...
    url: Any = ...
    type: Any = ...
    page: Any = ...
    target: Any = ...
    destination: Any = ...
    title: Any = ...
    contents: Any = ...
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    def complete(self, text, anchor: Any = ..., url: Any = ..., type: Any = ..., title: Any = ...): ...
    def computedestination(self): ...
    def setmutualdestination(self, destination): ...
    def __unicode__(self): ...

class URL(Link):
    url: Any = ...
    contents: Any = ...
    def process(self): ...

class FlexURL(URL):
    url: Any = ...
    def process(self): ...

class LinkOutput(ContainerOutput):
    def gethtml(self, link): ...

class Postprocessor:
    stages: Any = ...
    current: Any = ...
    last: Any = ...
    def __init__(self) -> None: ...
    def postprocess(self, next): ...
    def postrecursive(self, container): ...
    def postcurrent(self, next): ...

class StageDict:
    stagedict: Any = ...
    def __init__(self, classes, postprocessor) -> None: ...
    def instantiate(self, classes, postprocessor): ...
    def getstage(self, element): ...

class Label(Link):
    names: Any = ...
    lastlayout: Any = ...
    lastnumbered: Any = ...
    def __init__(self) -> None: ...
    def process(self): ...
    key: Any = ...
    def create(self, text, key, type: str = ...): ...
    def findpartkey(self): ...
    def numbered(self, container): ...
    def __unicode__(self): ...

class Reference(Link):
    references: Any = ...
    key: str = ...
    direction: str = ...
    destination: Any = ...
    def process(self): ...
    formatted: str = ...
    contents: Any = ...
    def formatcontents(self): ...
    def replace(self, key, value): ...
    def __unicode__(self): ...

class FormulaCommand(FormulaBit):
    types: Any = ...
    start: Any = ...
    commandmap: Any = ...
    def detect(self, pos): ...
    output: Any = ...
    def parsebit(self, pos): ...
    def parsewithcommand(self, command, pos): ...
    def parsecommandtype(self, command, type, pos): ...
    def extractcommand(self, pos): ...
    def emptycommand(self, pos): ...
    def parseupgreek(self, command, pos): ...

class CommandBit(FormulaCommand):
    command: Any = ...
    translated: Any = ...
    def setcommand(self, command): ...
    def parseparameter(self, pos): ...
    def parsesquare(self, pos): ...
    def parseliteral(self, pos): ...
    def parsesquareliteral(self, pos): ...
    def parsetext(self, pos): ...

class EmptyCommand(CommandBit):
    commandmap: Any = ...
    contents: Any = ...
    def parsebit(self, pos): ...

class SpacedCommand(CommandBit):
    commandmap: Any = ...
    contents: Any = ...
    def parsebit(self, pos): ...

class AlphaCommand(EmptyCommand):
    commandmap: Any = ...
    type: str = ...
    def parsebit(self, pos): ...

class OneParamFunction(CommandBit):
    commandmap: Any = ...
    simplified: bool = ...
    output: Any = ...
    def parsebit(self, pos): ...
    html: Any = ...
    def simplifyifpossible(self): ...

class SymbolFunction(CommandBit):
    commandmap: Any = ...
    def detect(self, pos): ...
    output: Any = ...
    def parsebit(self, pos): ...

class TextFunction(CommandBit):
    commandmap: Any = ...
    output: Any = ...
    def parsebit(self, pos): ...
    type: str = ...
    def process(self): ...

class LabelFunction(CommandBit):
    commandmap: Any = ...
    key: Any = ...
    def parsebit(self, pos): ...
    type: str = ...
    label: Any = ...
    contents: Any = ...
    def process(self): ...

class FontFunction(OneParamFunction):
    commandmap: Any = ...
    type: str = ...
    def process(self): ...

class BigSymbol:
    symbols: Any = ...
    symbol: Any = ...
    def __init__(self, symbol) -> None: ...
    def getpieces(self): ...
    def smalllimit(self): ...

class BigBracket(BigSymbol):
    size: Any = ...
    original: Any = ...
    alignment: Any = ...
    pieces: Any = ...
    def __init__(self, size, bracket, alignment: str = ...) -> None: ...
    def getpiece(self, index): ...
    def getpiece1(self, index): ...
    def getpiece3(self, index): ...
    def getpiece4(self, index): ...
    def getcell(self, index): ...
    def getcontents(self): ...
    def getsinglebracket(self): ...

class FormulaEquation(CommandBit):
    piece: str = ...
    output: Any = ...
    def parsebit(self, pos): ...

class FormulaCell(FormulaCommand):
    alignment: Any = ...
    output: Any = ...
    def setalignment(self, alignment): ...
    def parsebit(self, pos): ...

class FormulaRow(FormulaCommand):
    cellseparator: Any = ...
    alignments: Any = ...
    output: Any = ...
    def setalignments(self, alignments): ...
    def parsebit(self, pos): ...
    def createcell(self, index): ...

class MultiRowFormula(CommandBit):
    rows: Any = ...
    size: Any = ...
    def parserows(self, pos): ...
    def iteraterows(self, pos): ...
    def addempty(self): ...
    def addrow(self, row): ...

class FormulaArray(MultiRowFormula):
    piece: str = ...
    output: Any = ...
    def parsebit(self, pos): ...
    valign: str = ...
    alignments: Any = ...
    def parsealignments(self, pos): ...

class FormulaMatrix(MultiRowFormula):
    piece: str = ...
    output: Any = ...
    valign: str = ...
    alignments: Any = ...
    def parsebit(self, pos): ...

class FormulaCases(MultiRowFormula):
    piece: str = ...
    output: Any = ...
    alignments: Any = ...
    contents: Any = ...
    def parsebit(self, pos): ...

class EquationEnvironment(MultiRowFormula):
    output: Any = ...
    alignments: Any = ...
    def parsebit(self, pos): ...

class BeginCommand(CommandBit):
    commandmap: Any = ...
    types: Any = ...
    size: Any = ...
    def parsebit(self, pos): ...
    def findbit(self, piece): ...

class CombiningFunction(OneParamFunction):
    commandmap: Any = ...
    type: str = ...
    def parsebit(self, pos): ...
    def parsesingleparameter(self, pos): ...

class DecoratingFunction(OneParamFunction):
    commandmap: Any = ...
    type: str = ...
    symbol: Any = ...
    parameter: Any = ...
    output: Any = ...
    def parsebit(self, pos): ...

class LimitCommand(EmptyCommand):
    commandmap: Any = ...
    output: Any = ...
    def parsebit(self, pos): ...

class LimitPreviousCommand(LimitCommand):
    commandmap: Any = ...
    output: Any = ...
    def parsebit(self, pos): ...
    def __unicode__(self): ...

class LimitsProcessor(MathsProcessor):
    def process(self, contents, index): ...
    def checklimits(self, contents, index): ...
    def limitsahead(self, contents, index): ...
    def modifylimits(self, contents, index): ...
    def getlimit(self, contents, index): ...
    def modifyscripts(self, contents, index): ...
    def checkscript(self, contents, index): ...
    def checkcommand(self, contents, index, type): ...
    def getscript(self, contents, index): ...

class BracketCommand(OneParamFunction):
    commandmap: Any = ...
    def parsebit(self, pos): ...
    original: Any = ...
    command: Any = ...
    contents: Any = ...
    def create(self, direction, character): ...

class BracketProcessor(MathsProcessor):
    def process(self, contents, index): ...
    def processleft(self, contents, index): ...
    def checkleft(self, contents, index): ...
    def checkright(self, contents, index): ...
    def checkdirection(self, bit, command): ...
    def findright(self, contents, index): ...
    def findmax(self, contents, leftindex, rightindex): ...
    def resize(self, command, size): ...

class TodayCommand(EmptyCommand):
    commandmap: Any = ...
    output: Any = ...
    html: Any = ...
    def parsebit(self, pos): ...

class ParameterDefinition:
    parambrackets: Any = ...
    name: Any = ...
    literal: bool = ...
    optional: bool = ...
    value: Any = ...
    literalvalue: Any = ...
    def __init__(self) -> None: ...
    def parse(self, pos): ...
    def read(self, pos, function): ...
    def __unicode__(self): ...

class ParameterFunction(CommandBit):
    params: Any = ...
    def readparams(self, readtemplate, pos): ...
    def paramdefs(self, readtemplate): ...
    def getparam(self, name): ...
    def getvalue(self, name): ...
    def getliteralvalue(self, name): ...

class HybridFunction(ParameterFunction):
    commandmap: Any = ...
    contents: Any = ...
    def parsebit(self, pos): ...
    def writeparams(self, writetemplate): ...
    def writepos(self, pos): ...
    def writeparam(self, pos): ...
    def writefunction(self, pos): ...
    def readtag(self, pos): ...
    def writebracket(self, direction, character): ...
    size: Any = ...
    def computehybridsize(self): ...

class HybridSize:
    configsizes: Any = ...
    def getsize(self, function): ...

class HeaderParser(Parser):
    def parse(self, reader): ...
    def parseline(self, reader, contents): ...
    def parsebranch(self, reader): ...
    ending: Any = ...
    def complete(self, ending): ...

class PreambleParser(Parser):
    preamble: Any = ...
    ending: Any = ...
    def parse(self, reader): ...
    def parsepreambleline(self, reader): ...

class LstParser:
    globalparams: Any = ...
    def parselstset(self, reader): ...
    def extractlstset(self, reader): ...
    def parsecontainer(self, container): ...
    def parselstparams(self, paramlist): ...

class MacroDefinition(CommandBit):
    macros: Any = ...
    output: Any = ...
    parameternumber: int = ...
    defaults: Any = ...
    def parsebit(self, pos): ...
    newcommand: Any = ...
    definition: Any = ...
    def parseparameters(self, pos): ...
    def parsenewcommand(self, pos): ...
    def instantiate(self): ...

class MacroParameter(FormulaBit):
    def detect(self, pos): ...
    number: Any = ...
    original: Any = ...
    contents: Any = ...
    def parsebit(self, pos): ...

class MacroFunction(CommandBit):
    commandmap: Any = ...
    output: Any = ...
    values: Any = ...
    def parsebit(self, pos): ...
    def parseparameters(self, pos, macro): ...
    def parseoptional(self, pos, defaults): ...
    def parsemandatory(self, pos, number): ...
    def parsemacroparameter(self, pos, remaining): ...
    def parsenumbers(self, pos, remaining): ...
    contents: Any = ...
    def completemacro(self, macro): ...
    def addfilter(self, index, value): ...

class FormulaMacro(Formula):
    parser: Any = ...
    output: Any = ...
    def __init__(self) -> None: ...
    def __unicode__(self): ...

def math2html(formula): ...
def main(): ...
