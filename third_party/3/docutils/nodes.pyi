# Stubs for docutils.nodes (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

__docformat__: str

class Node:
    parent: Any = ...
    document: Any = ...
    source: Any = ...
    line: Any = ...
    def __bool__(self): ...
    def asdom(self, dom: Optional[Any] = ...): ...
    def pformat(self, indent: str = ..., level: int = ...): ...
    def copy(self): ...
    def deepcopy(self): ...
    def setup_child(self, child): ...
    def walk(self, visitor): ...
    def walkabout(self, visitor): ...
    def traverse(self, condition: Optional[Any] = ..., include_self: bool = ..., descend: bool = ..., siblings: bool = ..., ascend: bool = ...): ...
    def next_node(self, condition: Optional[Any] = ..., include_self: bool = ..., descend: bool = ..., siblings: bool = ..., ascend: bool = ...): ...

class reprunicode(str): ...
reprunicode = str

def ensure_str(s): ...

class Text(Node, reprunicode):
    tagname: str = ...
    children: Any = ...
    def __new__(cls, data, rawsource: Optional[Any] = ...): ...
    def __new__(cls, data, rawsource: Optional[Any] = ...): ...
    rawsource: Any = ...
    def __init__(self, data, rawsource: str = ...) -> None: ...
    def shortrepr(self, maxlen: int = ...): ...
    def astext(self): ...
    def copy(self): ...
    def deepcopy(self): ...
    def pformat(self, indent: str = ..., level: int = ...): ...
    def rstrip(self, chars: Optional[Any] = ...): ...
    def lstrip(self, chars: Optional[Any] = ...): ...

class Element(Node):
    basic_attributes: Any = ...
    local_attributes: Any = ...
    list_attributes: Any = ...
    known_attributes: Any = ...
    tagname: Any = ...
    child_text_separator: str = ...
    rawsource: Any = ...
    children: Any = ...
    attributes: Any = ...
    def __init__(self, rawsource: str = ..., *children, **attributes) -> None: ...
    def shortrepr(self): ...
    def __unicode__(self): ...
    def starttag(self, quoteattr: Optional[Any] = ...): ...
    def endtag(self): ...
    def emptytag(self): ...
    def __len__(self): ...
    def __contains__(self, key): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, item): ...
    def __delitem__(self, key): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __iadd__(self, other): ...
    def astext(self): ...
    def non_default_attributes(self): ...
    def attlist(self): ...
    def get(self, key, failobj: Optional[Any] = ...): ...
    def hasattr(self, attr): ...
    def delattr(self, attr): ...
    def setdefault(self, key, failobj: Optional[Any] = ...): ...
    has_key: Any = ...
    __contains__: Any = ...
    def get_language_code(self, fallback: str = ...): ...
    def append(self, item): ...
    def extend(self, item): ...
    def insert(self, index, item): ...
    def pop(self, i: int = ...): ...
    def remove(self, item): ...
    def index(self, item): ...
    def is_not_default(self, key): ...
    def update_basic_atts(self, dict_): ...
    def append_attr_list(self, attr, values): ...
    def coerce_append_attr_list(self, attr, value): ...
    def replace_attr(self, attr, value, force: bool = ...): ...
    def copy_attr_convert(self, attr, value, replace: bool = ...): ...
    def copy_attr_coerce(self, attr, value, replace): ...
    def copy_attr_concatenate(self, attr, value, replace): ...
    def copy_attr_consistent(self, attr, value, replace): ...
    def update_all_atts(self, dict_, update_fun: Any = ..., replace: bool = ..., and_source: bool = ...): ...
    def update_all_atts_consistantly(self, dict_, replace: bool = ..., and_source: bool = ...): ...
    def update_all_atts_concatenating(self, dict_, replace: bool = ..., and_source: bool = ...): ...
    def update_all_atts_coercion(self, dict_, replace: bool = ..., and_source: bool = ...): ...
    def update_all_atts_convert(self, dict_, and_source: bool = ...): ...
    def clear(self): ...
    def replace(self, old, new): ...
    def replace_self(self, new): ...
    def first_child_matching_class(self, childclass, start: int = ..., end: Any = ...): ...
    def first_child_not_matching_class(self, childclass, start: int = ..., end: Any = ...): ...
    def pformat(self, indent: str = ..., level: int = ...): ...
    def copy(self): ...
    def deepcopy(self): ...
    def set_class(self, name): ...
    referenced: int = ...
    def note_referenced_by(self, name: Optional[Any] = ..., id: Optional[Any] = ...): ...
    @classmethod
    def is_not_list_attribute(cls, attr): ...
    @classmethod
    def is_not_known_attribute(cls, attr): ...

class TextElement(Element):
    child_text_separator: str = ...
    def __init__(self, rawsource: str = ..., text: str = ..., *children, **attributes) -> None: ...

class FixedTextElement(TextElement):
    def __init__(self, rawsource: str = ..., text: str = ..., *children, **attributes) -> None: ...

class Resolvable:
    resolved: int = ...

class BackLinkable:
    def add_backref(self, refid): ...

class Root: ...
class Titular: ...
class PreBibliographic: ...
class Bibliographic: ...
class Decorative(PreBibliographic): ...
class Structural: ...
class Body: ...
class General(Body): ...
class Sequential(Body): ...
class Admonition(Body): ...
class Special(Body): ...
class Invisible(PreBibliographic): ...
class Part: ...
class Inline: ...
class Referential(Resolvable): ...

class Targetable(Resolvable):
    referenced: int = ...
    indirect_reference_name: Any = ...

class Labeled: ...

class document(Root, Structural, Element):
    current_source: Any = ...
    current_line: Any = ...
    settings: Any = ...
    reporter: Any = ...
    indirect_targets: Any = ...
    substitution_defs: Any = ...
    substitution_names: Any = ...
    refnames: Any = ...
    refids: Any = ...
    nameids: Any = ...
    nametypes: Any = ...
    ids: Any = ...
    footnote_refs: Any = ...
    citation_refs: Any = ...
    autofootnotes: Any = ...
    autofootnote_refs: Any = ...
    symbol_footnotes: Any = ...
    symbol_footnote_refs: Any = ...
    footnotes: Any = ...
    citations: Any = ...
    autofootnote_start: int = ...
    symbol_footnote_start: int = ...
    id_start: int = ...
    parse_messages: Any = ...
    transform_messages: Any = ...
    transformer: Any = ...
    decoration: Any = ...
    document: Any = ...
    def __init__(self, settings, reporter, *args, **kwargs) -> None: ...
    def asdom(self, dom: Optional[Any] = ...): ...
    def set_id(self, node, msgnode: Optional[Any] = ...): ...
    def set_name_id_map(self, node, id, msgnode: Optional[Any] = ..., explicit: Optional[Any] = ...): ...
    def set_duplicate_name_id(self, node, id, name, msgnode, explicit): ...
    def has_name(self, name): ...
    def note_implicit_target(self, target, msgnode: Optional[Any] = ...): ...
    def note_explicit_target(self, target, msgnode: Optional[Any] = ...): ...
    def note_refname(self, node): ...
    def note_refid(self, node): ...
    def note_indirect_target(self, target): ...
    def note_anonymous_target(self, target): ...
    def note_autofootnote(self, footnote): ...
    def note_autofootnote_ref(self, ref): ...
    def note_symbol_footnote(self, footnote): ...
    def note_symbol_footnote_ref(self, ref): ...
    def note_footnote(self, footnote): ...
    def note_footnote_ref(self, ref): ...
    def note_citation(self, citation): ...
    def note_citation_ref(self, ref): ...
    def note_substitution_def(self, subdef, def_name, msgnode: Optional[Any] = ...): ...
    def note_substitution_ref(self, subref, refname): ...
    def note_pending(self, pending, priority: Optional[Any] = ...): ...
    def note_parse_message(self, message): ...
    def note_transform_message(self, message): ...
    def note_source(self, source, offset): ...
    def copy(self): ...
    def get_decoration(self): ...

class title(Titular, PreBibliographic, TextElement): ...
class subtitle(Titular, PreBibliographic, TextElement): ...
class rubric(Titular, TextElement): ...
class docinfo(Bibliographic, Element): ...
class author(Bibliographic, TextElement): ...
class authors(Bibliographic, Element): ...
class organization(Bibliographic, TextElement): ...
class address(Bibliographic, FixedTextElement): ...
class contact(Bibliographic, TextElement): ...
class version(Bibliographic, TextElement): ...
class revision(Bibliographic, TextElement): ...
class status(Bibliographic, TextElement): ...
class date(Bibliographic, TextElement): ...
class copyright(Bibliographic, TextElement): ...

class decoration(Decorative, Element):
    def get_header(self): ...
    def get_footer(self): ...

class header(Decorative, Element): ...
class footer(Decorative, Element): ...
class section(Structural, Element): ...
class topic(Structural, Element): ...
class sidebar(Structural, Element): ...
class transition(Structural, Element): ...
class paragraph(General, TextElement): ...
class compound(General, Element): ...
class container(General, Element): ...
class bullet_list(Sequential, Element): ...
class enumerated_list(Sequential, Element): ...
class list_item(Part, Element): ...
class definition_list(Sequential, Element): ...
class definition_list_item(Part, Element): ...
class term(Part, TextElement): ...
class classifier(Part, TextElement): ...
class definition(Part, Element): ...
class field_list(Sequential, Element): ...
class field(Part, Element): ...
class field_name(Part, TextElement): ...
class field_body(Part, Element): ...

class option(Part, Element):
    child_text_separator: str = ...

class option_argument(Part, TextElement):
    def astext(self): ...

class option_group(Part, Element):
    child_text_separator: str = ...

class option_list(Sequential, Element): ...

class option_list_item(Part, Element):
    child_text_separator: str = ...

class option_string(Part, TextElement): ...
class description(Part, Element): ...
class literal_block(General, FixedTextElement): ...
class doctest_block(General, FixedTextElement): ...
class math_block(General, FixedTextElement): ...
class line_block(General, Element): ...

class line(Part, TextElement):
    indent: Any = ...

class block_quote(General, Element): ...
class attribution(Part, TextElement): ...
class attention(Admonition, Element): ...
class caution(Admonition, Element): ...
class danger(Admonition, Element): ...
class error(Admonition, Element): ...
class important(Admonition, Element): ...
class note(Admonition, Element): ...
class tip(Admonition, Element): ...
class hint(Admonition, Element): ...
class warning(Admonition, Element): ...
class admonition(Admonition, Element): ...
class comment(Special, Invisible, FixedTextElement): ...
class substitution_definition(Special, Invisible, TextElement): ...
class target(Special, Invisible, Inline, TextElement, Targetable): ...
class footnote(General, BackLinkable, Element, Labeled, Targetable): ...
class citation(General, BackLinkable, Element, Labeled, Targetable): ...
class label(Part, TextElement): ...
class figure(General, Element): ...
class caption(Part, TextElement): ...
class legend(Part, Element): ...
class table(General, Element): ...
class tgroup(Part, Element): ...
class colspec(Part, Element): ...
class thead(Part, Element): ...
class tbody(Part, Element): ...
class row(Part, Element): ...
class entry(Part, Element): ...

class system_message(Special, BackLinkable, PreBibliographic, Element):
    def __init__(self, message: Optional[Any] = ..., *children, **attributes) -> None: ...
    def astext(self): ...

class pending(Special, Invisible, Element):
    transform: Any = ...
    details: Any = ...
    def __init__(self, transform, details: Optional[Any] = ..., rawsource: str = ..., *children, **attributes) -> None: ...
    def pformat(self, indent: str = ..., level: int = ...): ...
    def copy(self): ...

class raw(Special, Inline, PreBibliographic, FixedTextElement): ...
class emphasis(Inline, TextElement): ...
class strong(Inline, TextElement): ...
class literal(Inline, TextElement): ...
class reference(General, Inline, Referential, TextElement): ...
class footnote_reference(Inline, Referential, TextElement): ...
class citation_reference(Inline, Referential, TextElement): ...
class substitution_reference(Inline, TextElement): ...
class title_reference(Inline, TextElement): ...
class abbreviation(Inline, TextElement): ...
class acronym(Inline, TextElement): ...
class superscript(Inline, TextElement): ...
class subscript(Inline, TextElement): ...
class math(Inline, TextElement): ...

class image(General, Inline, Element):
    def astext(self): ...

class inline(Inline, TextElement): ...
class problematic(Inline, TextElement): ...
class generated(Inline, TextElement): ...

node_class_names: Any

class NodeVisitor:
    optional: Any = ...
    document: Any = ...
    def __init__(self, document) -> None: ...
    def dispatch_visit(self, node): ...
    def dispatch_departure(self, node): ...
    def unknown_visit(self, node): ...
    def unknown_departure(self, node): ...

class SparseNodeVisitor(NodeVisitor): ...

class GenericNodeVisitor(NodeVisitor):
    def default_visit(self, node): ...
    def default_departure(self, node): ...

class TreeCopyVisitor(GenericNodeVisitor):
    parent_stack: Any = ...
    parent: Any = ...
    def __init__(self, document) -> None: ...
    def get_tree_copy(self): ...
    def default_visit(self, node): ...
    def default_departure(self, node): ...

class TreePruningException(Exception): ...
class SkipChildren(TreePruningException): ...
class SkipSiblings(TreePruningException): ...
class SkipNode(TreePruningException): ...
class SkipDeparture(TreePruningException): ...
class NodeFound(TreePruningException): ...
class StopTraversal(TreePruningException): ...

def make_id(string): ...
def dupname(node, name): ...
def fully_normalize_name(name): ...
def whitespace_normalize_name(name): ...
def serial_escape(value): ...
def pseudo_quoteattr(value): ...
